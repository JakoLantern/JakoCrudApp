# üìä Firestore Collections Structure

> ‚ö†Ô∏è **DEPRECATED**: This document describes an old structure using `slots` collection.
> 
> **Please refer to [NORMALIZED_STRUCTURE.md](./NORMALIZED_STRUCTURE.md) for the current implementation.**
> 
> The current implementation uses a normalized structure with:
> - `dates` collection (61 docs) - one per date with availableTimeIds array
> - `times` collection (16 docs) - one per time slot
> - `appointments` collection - one per booking
> - `users` collection - user profiles

## Collections Overview (OLD STRUCTURE - NOT USED)
This app uses 3 main collections: `users`, `slots`, and `appointments`

---

## 1Ô∏è‚É£ **`users`** Collection
Stores user profile information (extends Firebase Auth)

```typescript
// Document ID: Firebase Auth UID
{
  uid: string,              // Firebase Auth user ID
  email: string,            // User's email
  firstName: string,        // User's first name
  lastName: string,         // User's last name
  createdAt: Timestamp,     // Account creation timestamp
  updatedAt: Timestamp      // Last profile update
}
```

**Example:**
```
users/abc123xyz
{
  uid: "abc123xyz",
  email: "john.doe@example.com",
  firstName: "John",
  lastName: "Doe",
  createdAt: 2025-10-01T10:00:00Z,
  updatedAt: 2025-10-01T10:00:00Z
}
```

---

## 2Ô∏è‚É£ **`slots`** Collection
Stores available time slots (inventory/availability)

```typescript
// Document ID: "YYYY-MM-DD_HH-MM_AM/PM" (e.g., "2025-10-15_08-00_AM")
{
  slotId: string,           // Matches document ID
  date: string,             // "YYYY-MM-DD" format
  time: string,             // "H:MM AM/PM" format
  isAvailable: boolean,     // true = available, false = booked
  createdAt: Timestamp      // When slot was created
}
```

**Example:**
```
slots/2025-10-15_08-00_AM
{
  slotId: "2025-10-15_08-00_AM",
  date: "2025-10-15",
  time: "8:00 AM",
  isAvailable: true,
  createdAt: 2025-10-01T00:00:00Z
}
```

**Seeded Data:**
- **Dates**: October 1-31, November 1-30, 2025 (61 days)
- **Times**: 8:00 AM to 3:30 PM in 30-minute intervals (16 slots/day)
- **Total**: 976 slots

---

## 3Ô∏è‚É£ **`appointments`** Collection
Stores booking records (transactions)

```typescript
// Document ID: Auto-generated by Firestore
{
  appointmentId: string,    // Matches document ID
  slotId: string,           // Reference to slots/{slotId}
  userId: string,           // Reference to users/{userId}
  date: string,             // "YYYY-MM-DD" (denormalized for queries)
  time: string,             // "H:MM AM/PM" (denormalized for queries)
  status: 'confirmed' | 'cancelled',
  createdAt: Timestamp,     // When appointment was booked
  cancelledAt?: Timestamp   // When cancelled (if applicable)
}
```

**Example:**
```
appointments/xyz789def
{
  appointmentId: "xyz789def",
  slotId: "2025-10-15_08-00_AM",
  userId: "abc123xyz",
  date: "2025-10-15",
  time: "8:00 AM",
  status: "confirmed",
  createdAt: 2025-10-01T14:30:00Z
}
```

---

## üîÑ Booking Workflow

### **1. Get Available Slots for a Date**
```typescript
const availableSlots = await getDocs(
  query(
    collection(db, 'slots'),
    where('date', '==', '2025-10-15'),
    where('isAvailable', '==', true)
  )
);
```

### **2. Book an Appointment (Transaction)**
```typescript
await runTransaction(db, async (transaction) => {
  // 1. Mark slot as unavailable
  transaction.update(doc(db, 'slots', slotId), { 
    isAvailable: false 
  });
  
  // 2. Create appointment record
  const appointmentRef = doc(collection(db, 'appointments'));
  transaction.set(appointmentRef, {
    appointmentId: appointmentRef.id,
    slotId,
    userId,
    date,
    time,
    status: 'confirmed',
    createdAt: serverTimestamp()
  });
});
```

### **3. Get User's Appointments**
```typescript
const userAppointments = await getDocs(
  query(
    collection(db, 'appointments'),
    where('userId', '==', userId),
    where('status', '==', 'confirmed'),
    orderBy('date', 'asc')
  )
);
```

### **4. Cancel an Appointment**
```typescript
await runTransaction(db, async (transaction) => {
  // 1. Mark slot as available again
  transaction.update(doc(db, 'slots', slotId), { 
    isAvailable: true 
  });
  
  // 2. Update appointment status
  transaction.update(doc(db, 'appointments', appointmentId), {
    status: 'cancelled',
    cancelledAt: serverTimestamp()
  });
});
```

---

## üîê Firestore Security Rules

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Users collection - users can read/write their own data
    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Slots collection - anyone can read, no one can write (only via server)
    match /slots/{slotId} {
      allow read: if request.auth != null;
      allow write: if false; // Only server/admin can modify
    }
    
    // Appointments collection - users can read their own, write with validation
    match /appointments/{appointmentId} {
      allow read: if request.auth != null && 
                     resource.data.userId == request.auth.uid;
      allow create: if request.auth != null && 
                       request.resource.data.userId == request.auth.uid;
      allow update: if request.auth != null && 
                       resource.data.userId == request.auth.uid;
      allow delete: if false; // Don't delete, only cancel
    }
  }
}
```

---

## üìà Indexes Required

Create these composite indexes in Firebase Console:

1. **Slots by date and availability:**
   - Collection: `slots`
   - Fields: `date` (Ascending), `isAvailable` (Ascending)

2. **Appointments by user and status:**
   - Collection: `appointments`
   - Fields: `userId` (Ascending), `status` (Ascending), `date` (Ascending)

---

## üéØ Benefits of This Structure

‚úÖ **Separation of Concerns**: Slots = inventory, Appointments = bookings
‚úÖ **Atomic Transactions**: Use Firestore transactions for consistency
‚úÖ **Fast Queries**: Indexed queries for common operations
‚úÖ **History Tracking**: Keep cancelled appointments for records
‚úÖ **Scalability**: Industry-standard pattern (inventory + reservations)
