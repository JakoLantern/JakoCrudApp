# Firebase Firestore Collections Design

## 📊 Recommended Collections Structure

Based on your Angular CRUD appointment booking app, here are the collections you'll need:

---

## 1️⃣ **`users`** Collection
Stores user profile information (extends Firebase Auth data)

```typescript
// Document ID: matches Firebase Auth UID
{
  uid: string,              // Firebase Auth user ID
  email: string,            // User's email
  firstName: string,        // From registration
  lastName: string,         // From registration
  role: 'patient' | 'admin' | 'doctor',  // User role
  phoneNumber?: string,     // Optional
  createdAt: Timestamp,     // Account creation date
  updatedAt: Timestamp      // Last profile update
}
```

**Example Document:**
```
users/abc123xyz
{
  uid: "abc123xyz",
  email: "john.doe@example.com",
  firstName: "John",
  lastName: "Doe",
  role: "patient",
  phoneNumber: "+1234567890",
  createdAt: 2025-10-01T10:00:00Z,
  updatedAt: 2025-10-01T10:00:00Z
}
```

---

## 2️⃣ **`appointments`** Collection
Stores all appointment bookings

```typescript
{
  id: string,               // Auto-generated by Firestore
  userId: string,           // Reference to users collection (who booked it)
  patientName: string,      // Full name of patient
  patientEmail: string,     // Contact email
  patientPhone?: string,    // Contact phone
  date: string,             // Date in YYYY-MM-DD format
  time: string,             // Time in HH:MM format (24-hour)
  slotId: string,           // Reference to time_slots collection
  reason?: string,          // Reason for appointment
  notes?: string,           // Additional notes
  status: 'pending' | 'confirmed' | 'completed' | 'cancelled',
  createdAt: Timestamp,     // When appointment was booked
  updatedAt: Timestamp      // Last modification
}
```

**Example Document:**
```
appointments/appt001
{
  id: "appt001",
  userId: "abc123xyz",
  patientName: "John Doe",
  patientEmail: "john.doe@example.com",
  patientPhone: "+1234567890",
  date: "2025-10-15",
  time: "14:00",
  slotId: "slot_20251015_1400",
  reason: "Regular checkup",
  notes: "First time patient",
  status: "confirmed",
  createdAt: 2025-10-01T10:00:00Z,
  updatedAt: 2025-10-01T10:00:00Z
}
```

---

## 3️⃣ **`time_slots`** Collection
Stores available time slots for booking

```typescript
{
  id: string,               // Auto-generated or formatted (e.g., slot_YYYYMMDD_HHMM)
  date: string,             // YYYY-MM-DD
  time: string,             // HH:MM (24-hour)
  duration: number,         // Duration in minutes (e.g., 30, 60)
  isAvailable: boolean,     // Is the slot still available?
  isLocked: boolean,        // Is someone currently booking it?
  lockedBy?: string,        // User ID who locked it
  lockedAt?: Timestamp,     // When it was locked
  maxCapacity: number,      // How many can book this slot (usually 1)
  bookedCount: number,      // Current bookings for this slot
  doctorId?: string,        // If specific to a doctor
  createdAt: Timestamp,
  updatedAt: Timestamp
}
```

**Example Document:**
```
time_slots/slot_20251015_1400
{
  id: "slot_20251015_1400",
  date: "2025-10-15",
  time: "14:00",
  duration: 30,
  isAvailable: true,
  isLocked: false,
  lockedBy: null,
  lockedAt: null,
  maxCapacity: 1,
  bookedCount: 0,
  doctorId: "doc001",
  createdAt: 2025-10-01T10:00:00Z,
  updatedAt: 2025-10-01T10:00:00Z
}
```

---

## 4️⃣ **`doctors`** Collection (Optional)
If you have multiple doctors/service providers

```typescript
{
  id: string,
  firstName: string,
  lastName: string,
  specialty: string,
  email: string,
  availability: {
    monday: string[],      // Array of time slots ["09:00", "10:00", ...]
    tuesday: string[],
    // ... other days
  },
  isActive: boolean,
  createdAt: Timestamp,
  updatedAt: Timestamp
}
```

---

## 5️⃣ **`slot_locks`** Collection (For Time-Slot Locking)
Temporary locks to prevent double-booking

```typescript
{
  id: string,               // Auto-generated
  slotId: string,           // Reference to time_slots
  userId: string,           // Who locked it
  lockedAt: Timestamp,      // When locked
  expiresAt: Timestamp      // Auto-expires after 5-10 minutes
}
```

**Example Document:**
```
slot_locks/lock001
{
  id: "lock001",
  slotId: "slot_20251015_1400",
  userId: "abc123xyz",
  lockedAt: 2025-10-01T10:00:00Z,
  expiresAt: 2025-10-01T10:10:00Z  // 10 minutes later
}
```

---

## 📋 Collection Relationships

```
users (1) ──────────> (many) appointments
users (1) ──────────> (many) slot_locks
time_slots (1) ─────> (many) appointments
time_slots (1) ─────> (many) slot_locks
doctors (1) ────────> (many) time_slots (optional)
```

---

## 🔒 Firestore Security Rules

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Users can only read/write their own data
    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth.uid == userId;
    }
    
    // Appointments - users can only manage their own
    match /appointments/{appointmentId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow update, delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }
    
    // Time slots - read by all authenticated users, write by admins only
    match /time_slots/{slotId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    // Slot locks - users can only create/read their own locks
    match /slot_locks/{lockId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null && (
        resource.data.userId == request.auth.uid || 
        request.time > resource.data.expiresAt
      );
    }
    
    // Doctors - read by all, write by admins
    match /doctors/{doctorId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
  }
}
```

---

## 🎯 Key Features Enabled

### ✅ **CRUD Operations**
- **Create**: Add new appointments
- **Read**: View appointments list/details
- **Update**: Modify appointment details
- **Delete**: Cancel appointments

### ✅ **Time-Slot Locking**
- Lock a slot when user starts booking
- Auto-expire after 10 minutes
- Prevent double-booking

### ✅ **User Management**
- Firebase Auth for authentication
- Custom user profiles in Firestore
- Role-based access (patient/admin/doctor)

### ✅ **Real-time Updates**
- Use Firestore's `onSnapshot()` for live data
- See appointments update in real-time
- Slot availability updates instantly

---

## 📊 Indexes to Create

In Firebase Console → Firestore → Indexes, create these composite indexes:

### **appointments**
```
Collection: appointments
Fields: userId (Ascending), createdAt (Descending)
```

### **time_slots**
```
Collection: time_slots
Fields: date (Ascending), isAvailable (Ascending)
```

### **slot_locks**
```
Collection: slot_locks
Fields: slotId (Ascending), expiresAt (Ascending)
```

---

## 🚀 Quick Start Data Structure

### **Minimal Setup (Just 2 Collections):**
If you want to start simple:
1. **`users`** - User profiles
2. **`appointments`** - Bookings only

### **Full Setup (All 5 Collections):**
For production-ready app:
1. **`users`** - User profiles
2. **`appointments`** - Bookings
3. **`time_slots`** - Available slots
4. **`doctors`** - Service providers (if multiple)
5. **`slot_locks`** - Prevent double-booking

---

## 💡 Recommended: Start with 3 Collections

For your MVP, I recommend:
1. ✅ **`users`** - User management
2. ✅ **`appointments`** - CRUD operations
3. ✅ **`time_slots`** - Slot management & locking

You can add `doctors` and separate `slot_locks` later as needed.

---

## 📝 Next Steps

1. **Create collections** in Firebase Console → Firestore
2. **Set up security rules** (copy from above)
3. **Create indexes** for better query performance
4. **Add sample data** to test
5. **Integrate with your Angular components**

Your collections are now designed for a full-featured appointment booking system! 🎉
